# 1
1. 发生了写请求A，A的第一步淘汰了cache
1. A的第二步写数据库，发出修改请求
1. 发生了读请求B，B的第一步读取cache，发现cache中是空的
1. B的第二步读取数据库，发出读取请求，此时A的第二步写数据还没完成，读出了一个脏数据放入cache

### 即在数据库层面，后发出的请求4比先发出的请求2先完成了，读出了脏数据，脏数据又入了缓存，缓存与数据库中的数据不一致出现了

### 其实不需要让全局的请求串行化，而只需要“让同一个数据的访问能串行化”就行。

如何做到“让同一个数据的访问通过同一条DB连接执行”，只需要“在DB连接池层面稍微修改，按数据取连接即可”

获取DB连接的CPool.GetDBConnection()【返回任何一个可用DB连接】改为

CPool.GetDBConnection(longid)【返回id取模相关联的DB连接】


# 2 使用旁路缓存模式与双删策略