MVCC全称叫做多版本并发控制，主要由undo log，Read View，三个隐藏字段来实现的

有两个概念需要先说明一下，

1. 当前读：比如select for update ，lock in share mode，insert，update，delete 就是当前读，当前读会给这条记录加锁，禁止其他线程对这条记录进行修改

2. 快照读：快照读是由MVCC实现的，快照读不会对记录加锁，快照读会根据当前事务生成一个试图，读到的有可能不是最新的数据。前提是隔离级别不是串行，串行级别下快照读会退化成当前读

在数据库中，每条记录除了表定义的字段，还有三个隐藏字段，分别是隐藏主键，事务Id和指向上一个版本的指针
在一个事务对一条记录进行写操作的时候，会首先加锁，然后拷贝该记录到undo log中，然后将更新后的记录写入数据库，事务Id字段会记录当前事务的Id，这是一个会不断递增的值，指针则会指向在undo log中的上一条记录
那么假如事务异常导致回滚了，undo log就会将这条记录写回表中，就完成了回滚
这是MVCC对写操作的流程

在读的时候，事务会生成一个Read View
Read View 中有三个全局属性
trx_list： 维护活跃Id的列表
up_limit_id: 记录trx_list列表中事务Id的最小ID
low_limit_id: 记录Read View 生成时刻系统尚未分配的下一个事务ID

读视图在生成的时候会用可见性算法来做可见性判断，
主要是将当前事务Id与活跃事务id做对比，如果不符合可见性，就会通过回滚指针去除undolog中的事务Id作比较，去undo log中遍历找到对应的可见的记录来生成视图。
比较规则如下：
1. 首先比较 db_trx_id < up_limit_id,则符合可见性,大于则进入下一个判断
2. 判断 DB_TRX_ID >= low_limit_id,表示DB_TRX_ID在Read View之后出现，不可见性，如果小于，则进入下一个判断
3. 判断DB_TRX_ID是否在活跃事务中，在的话，说明当前事务还没commit，修改的数据也是看不到的，如果不在，则说明这个事务在Read View生成之前已经commit，那么是可见的

如果隔离级别是RC，那么事务中的每次查询都会生成一个最新的读视图，如果隔离级别是RR，那么只有在事务的第一次查询才会生成读视图
