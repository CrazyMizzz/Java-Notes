# 总

什么是循环依赖问题？ A依赖B，B依赖A

# 分
1. 三级缓存
2. 提前暴露对象
3. aop

先说明bean的创建过程：实例化，初始化（填充属性）

1. 创建A对象
2. 实例化A对象，b=null
3. 初始化A对象，给b赋值，从容器中找b对象
    
    - 找到了直接赋值即可
    - 没找到，创建B对象，形成闭环

所以解决问题的核心在于实例化和初始化分开操作，这是解决循环依赖的关键

当所有的对象都完成实例化和初始化操作以后，还要把完整对象放到容器中，此时容器存在对象的几个状态，完成实例化但未完成初始化，和完整的bean，因为都在容器中，所以用不同的map结构来存储，于是有了一级和二级缓存。一级缓存中存放的是完整对象，二级缓存中存放的是非完整对象。查找顺寻按照1，2，3的顺序来查找来保证不会存在同名的对象。

三级缓存的value类型是ObjectFactory，是一个函数式接口，存在的意义是保证在整个容器的运行过程中同名的bean对象只能有一个

普通对象和代理对象不能同时出现在容器中，如果一个对象需要被代理，就会用代理对象覆盖掉之前实例化的普通对象，在实际的调用过程中，没有办法确定什么时候对象被使用，所以就要求当某个对象被调用的时候，优先判断是否需要被代理。类似于一种回调机制的实现，因此传入lamda表达式的时候，可以通过lambda表达式来执行对对象的覆盖过程，getEarlyBeanReference（）

因此所有的bean对象在创建的时候都要优先放到三级缓存中，在后续的使用过程中，如果需要被代理则返回代理对象，如果不需要被代理，则直接返回普通对象  